<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SVG Highlighter — elements & packages</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    .wrap { display: grid; gap: 12px; }
    .note { font-size: 14px; opacity: .8; }
    .toolbar {
      position: fixed; right: 18px; bottom: 18px;
      display: grid; gap: 8px; z-index: 9999;
    }
    .toolbtn {
      border: 1px solid #ccc; background: #fff;
      padding: 8px 10px; border-radius: 8px; font: inherit; cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }
    .toolbtn:active { transform: translateY(1px); }
    .is-grab { cursor: grab; }
    .is-grabbing { cursor: grabbing; }
    object, object:focus { touch-action: none; }
    html, body { user-select: none; -webkit-user-select: none; }

    .pkgbar {
      position: fixed; left: 18px; top: 18px;
      display: grid; gap: 6px; z-index: 9999;
      max-height: calc(100vh - 36px); overflow: auto; padding-right: 4px; margin-top: 200px;
    }
    .pkgbtn {
      border: 1px solid #ccc; background: #fff; padding: 6px 10px;
      border-radius: 8px; font: 13px system-ui, sans-serif; cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.08); text-align: left; white-space: nowrap;
    }
    .pkgbtn:active { transform: translateY(1px); }
    .pkgbtn.is-active { border-color: #4b9cff; box-shadow: 0 0 0 2px rgba(75,156,255,.2); }
  </style>
</head>
<body>
  <div class="pkgbar" id="pkgPanel">
    <button class="pkgbtn" id="clearPkgBtn" title="Clear highlight">Clear</button>
  </div>

  <div class="wrap" style="margin-left: 200px;">
    <h1>Highlight and select elements</h1>
    <div class="note">
      - Click an element to select and highlight it.<br/>
      - Click on the white or empty area to deselect.<br/>
      - Scroll to zoom, drag to pan, double-click to zoom in, use the buttons to reset.
      - use searchbar to quickly find elements
     <ul> <li><strong>Metrics</strong> <ul> <li>Simplified the model: dropped <code>Measurement</code>, <code>GeneralMetric</code>, and <code>MechanicMetric</code>; kept a single <code>Metric</code> concept with concrete instances.</li> <li>Added <code>DailyAdherence</code> and <code>WeeklyAdherence</code> as instances of <code>Metric</code>.</li> <li><code>MetricComputation</code> now produces <code>Metric</code> and takes input from <code>Telemetry.EventCollection</code> (triggered by <code>Telemetry.Event</code>).</li> </ul> </li> <li><strong>Telemetry (new)</strong> <ul> <li>Introduced <code>Event</code> with subtypes <code>UserEvent</code> and <code>SystemEvent</code>, plus <code>EventCollection</code> to aggregate events.</li> <li>Events now trigger <code>KeySituation</code> and kick off <code>MetricComputation</code>; <code>User</code> is the actor of events.</li> </ul> </li> <li><strong>KeySituations</strong> <ul> <li>Collapsed the previous subtype tree into one <code>KeySituation</code> concept with named instances; still linked to <code>Intervention</code> via “triggers”.</li> </ul> </li> <li><strong>Interventions</strong> <ul> <li>Streamlined the hierarchy: removed <code>ImmediateIntervention</code>, <code>MechanicIntervention</code>, and scheduling constructs; kept <code>Questionnaire</code> and <code>AlertMessage</code> under <code>Intervention</code>.</li> </ul> </li> <li><strong>Program_and_Tasks</strong> <ul> <li>Dropped adherence calculation links to <code>Task</code>/<code>TaskRequirement</code> and the <code>Program → KeySituation</code> trigger.</li> </ul> </li> <li><strong>UserModel</strong> <ul> <li>Replaced <code>User → UserAction</code> with <code>User → Telemetry.Event</code> (actor).</li> <li>States (<code>MotivationalState</code>, <code>CognitiveLoadState</code>) “read” <code>Metric</code>; <code>MotivationalState</code> is derived from <code>WeeklyAdherence</code>.</li> </ul> </li> <li><strong>MotivationalMechanics</strong> <ul> <li>Kept the <code>Mapping</code> concept; removed the old <code>MechanicTraitWeight</code>; mappings reference <code>UserTrait</code> and <code>MotivationalMechanic</code>.</li> </ul> </li> </ul>
    </div>

    <input id="searchBox" list="graphTerms" placeholder="Search element…"
       style="margin-left:auto; padding:6px 8px; border:1px solid #ccc; border-radius:8px; min-width:240px;">
    <datalist id="graphTerms"></datalist>

    <object id="svgObj" type="image/svg+xml" data="./UML_ontology.svg"
            width="100%" style="border:1px solid #ccc; max-height: 80vh;"></object>
  </div>

  <div class="toolbar" aria-label="Zoom controls">
    <button class="toolbtn" id="zoomInBtn"  title="Zoom in ( + )">+</button>
    <button class="toolbtn" id="zoomOutBtn" title="Zoom out ( – )">−</button>
    <button class="toolbtn" id="resetBtn"   title="Reset view ( 0 )">Reset</button>
  </div>

  <script>
  // ====== Helpers ======
  function normalizeId(str) {
    return (str || '').replace(/^elem_/,'').replace(/^link_/,'').replace(/^cluster_/,'')
      .toLowerCase().replace(/[^a-z0-9]+/g,'');
  }
  function tokensFromId(id) { return (id || '').split(/_to_|_/).map(normalizeId).filter(Boolean); }
  function bboxContains(outer, inner, padding = 0) {
    return (inner.x >= outer.x - padding &&
            inner.y >= outer.y - padding &&
            inner.x + inner.width  <= outer.x + outer.width  + padding &&
            inner.y + inner.height <= outer.y + outer.height + padding);
  }

  // ====== Pan/zoom utilities ======
  function unionContentBBox(svg) {
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity, any=false;
    svg.querySelectorAll('*').forEach(node=>{
      if (node instanceof SVGGraphicsElement && typeof node.getBBox==='function') {
        try{
          const b=node.getBBox();
          if([b.x,b.y,b.width,b.height].every(Number.isFinite)){
            minX=Math.min(minX,b.x); minY=Math.min(minY,b.y);
            maxX=Math.max(maxX,b.x+b.width); maxY=Math.max(maxY,b.y+b.height);
            any=true;
          }
        }catch{}
      }
    });
    if(!any) return null;
    return { x:minX, y:minY, width:Math.max(1,maxX-minX), height:Math.max(1,maxY-minY) };
  }
  function ensureViewBox(svg){
    const vb = svg.viewBox && svg.viewBox.baseVal;
    if (vb && vb.width>0 && vb.height>0) return { x:vb.x, y:vb.y, width:vb.width, height:vb.height };
    const u=unionContentBBox(svg);
    if(u){ svg.setAttribute('viewBox', `${u.x} ${u.y} ${u.width} ${u.height}`); return u; }
    const w=parseFloat(svg.getAttribute('width'))||100, h=parseFloat(svg.getAttribute('height'))||100;
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`); return { x:0, y:0, width:w, height:h };
  }
  function setViewBox(svg, vb){ svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`); }
  function clientPointToSvg(svg, clientX, clientY){
    const pt=svg.createSVGPoint(); pt.x=clientX; pt.y=clientY;
    const ctm=svg.getScreenCTM(); if(!ctm) return {x:0,y:0};
    const p=pt.matrixTransform(ctm.inverse()); return { x:p.x, y:p.y };
  }
  function zoomAt(svg, state, center, factor){
    const { vb0, vb } = state;
    const newW = vb.width * factor;
    const minW = vb0.width / 10, maxW = vb0.width * 5;
    const clampedW = Math.min(Math.max(newW, minW), maxW);
    const scaleAdj = clampedW / vb.width;
    const newH = vb.height * scaleAdj;
    const sx = (center.x - vb.x) / vb.width;
    const sy = (center.y - vb.y) / vb.height;
    vb.x = center.x - sx * clampedW;
    vb.y = center.y - sy * newH;
    vb.width = clampedW;
    vb.height = newH;
    setViewBox(svg, vb);
  }
  function panBy(svg, state, dx, dy){ state.vb.x += dx; state.vb.y += dy; setViewBox(svg, state.vb); }

  const svgObj = document.getElementById('svgObj');

  svgObj.addEventListener('load', () => {
    const svgDoc  = svgObj.contentDocument;
    if (!svgDoc) { console.warn('SVG contentDocument not available.'); return; }
    const svgRoot = svgDoc.documentElement;
    if (!svgRoot || svgRoot.nodeName.toLowerCase() !== 'svg') { console.warn('Embedded doc is not <svg>.'); return; }

    svgRoot.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    svgRoot.style.touchAction = 'none';
    svgRoot.style.userSelect = 'none';
    svgRoot.style.webkitUserSelect = 'none';

    // Init pan/zoom state
    const vbInit = ensureViewBox(svgRoot);
    const state = { vb0: { ...vbInit }, vb:  { ...vbInit } };

    // ====== Wheel zoom ======
    let wheelFrame = null, wheelAccum = 0, lastWheelCenter = null;
    function normalizeDeltaY(e){ if(e.deltaMode===1)return e.deltaY*16; if(e.deltaMode===2)return e.deltaY*800; return e.deltaY; }
    const ZOOM_SENS = 0.0015;
    function onWheelSmooth(e){
      e.preventDefault(); e.stopPropagation();
      lastWheelCenter = clientPointToSvg(svgRoot, e.clientX, e.clientY);
      wheelAccum += normalizeDeltaY(e);
      if(!wheelFrame){
        wheelFrame = requestAnimationFrame(()=>{
          zoomAt(svgRoot, state, lastWheelCenter, Math.exp(ZOOM_SENS*wheelAccum));
          wheelAccum=0; wheelFrame=null;
        });
      }
    }
    svgRoot.addEventListener('wheel', onWheelSmooth, { passive: false });

    // ====== Drag to pan with click/drag separation ======
    svgRoot.classList.add('is-grab');
    let isDragging=false, pointerId=null, lastClientX=0, lastClientY=0, panDX=0, panDY=0, panFrame=null;
    let movedPx=0; const DRAG_THRESHOLD=5;

    function flushPan(){
      panFrame=null;
      if(!isDragging || (panDX===0 && panDY===0)) return;
      const rect=svgRoot.getBoundingClientRect();
      const sx=state.vb.width/rect.width, sy=state.vb.height/rect.height;
      const dxSVG=panDX*sx, dySVG=panDY*sy;
      panDX=0; panDY=0; panBy(svgRoot, state, -dxSVG, -dySVG);
    }
    function onPointerDown(e){
      if(e.button!==undefined && e.button!==0) return;
      e.preventDefault();
      pointerId=e.pointerId; isDragging=true; movedPx=0;
      lastClientX=e.clientX; lastClientY=e.clientY;
      svgRoot.classList.remove('is-grab'); svgRoot.classList.add('is-grabbing');
      try{(e.target.setPointerCapture||svgRoot.setPointerCapture)?.call(e.target,e.pointerId);}catch{}
    }
    function onPointerMove(e){
      if(!isDragging || (pointerId!==null && e.pointerId!==pointerId)) return;
      const dx=e.clientX-lastClientX, dy=e.clientY-lastClientY;
      lastClientX=e.clientX; lastClientY=e.clientY;
      movedPx += Math.hypot(dx,dy);
      panDX+=dx; panDY+=dy;
      if(!panFrame){ panFrame=requestAnimationFrame(flushPan); }
    }
    function onPointerUpOrCancel(e){
      if(!isDragging || (pointerId!==null && e.pointerId!==pointerId)) return;
      isDragging=false; pointerId=null; flushPan();
      svgRoot.classList.remove('is-grabbing'); svgRoot.classList.add('is-grab');
      try{(e.target.releasePointerCapture||svgRoot.releasePointerCapture)?.call(e.target,e.pointerId);}catch{}
    }
    svgRoot.addEventListener('pointerdown', onPointerDown, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointermove', onPointerMove, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointerup', onPointerUpOrCancel, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointercancel', onPointerUpOrCancel, { passive:false });

    // ====== Keyboard shortcuts ======
    svgRoot.ownerDocument.addEventListener('keydown', (e) => {
      if (e.key === '+') {
        const r=svgRoot.getBoundingClientRect(); const c=clientPointToSvg(svgRoot,r.left+r.width/2,r.top+r.height/2);
        zoomAt(svgRoot, state, c, 1/1.1);
      } else if (e.key === '-') {
        const r=svgRoot.getBoundingClientRect(); const c=clientPointToSvg(svgRoot,r.left+r.width/2,r.top+r.height/2);
        zoomAt(svgRoot, state, c, 1.1);
      } else if (e.key === '0') {
        state.vb = { ...state.vb0 }; setViewBox(svgRoot, state.vb);
      }
    });

    // ====== Injected styles for highlighting ======
    const style = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `
      svg { touch-action:none; user-select:none; -webkit-user-select:none; }
      .is-dimmed { opacity:.4; transition:opacity .12s; }

      .is-node-highlight rect,
      .is-node-highlight path,
      .is-node-highlight polygon {
        stroke:#000 !important;
        stroke-width:3 !important;
      }

      .is-link-highlight path:not(.hit),
      .is-link-highlight line:not(.hit),
      .is-link-highlight polyline:not(.hit) {
        stroke:#000 !important;
        stroke-width:2.5 !important;
      }

      .is-node-highlight text {
        font-weight:700;
        paint-order:stroke;
        stroke:#fff;
        stroke-width:1.5;
        stroke-opacity:.9;
      }

      g[id^="elem_"], g[id^="cluster_"] { cursor: pointer; }

      /* Oversized invisible hit geometry for links */
      g[id^="link_"] .hit {
        stroke:#000; stroke-opacity:0.001; stroke-width:300;
        fill:none; vector-effect:non-scaling-stroke; pointer-events: stroke; cursor: pointer;
      }
      g[id^="link_"] path:not(.hit),
      g[id^="link_"] line:not(.hit),
      g[id^="link_"] polyline:not(.hit),
      g[id^="link_"] polygon:not(.hit) { pointer-events: none; }
    `;
    svgRoot.appendChild(style);

    // ====== Highlight logic ======
    const elemGroups    = Array.from(svgDoc.querySelectorAll('g[id^="elem_"]'));
    const clusterGroups = Array.from(svgDoc.querySelectorAll('g[id^="cluster_"]'));
    const linkGroups    = Array.from(svgDoc.querySelectorAll('g[id^="link_"]'));
    const allNodeGroups = [...elemGroups, ...clusterGroups];

    // Build hit geometry for all link primitives
    linkGroups.forEach(g => g.dataset.tokens = JSON.stringify(tokensFromId(g.id)));
    linkGroups.forEach(g => {
      g.querySelectorAll('path,line,polyline,polygon').forEach(el => {
        const hit = el.cloneNode(false);
        hit.classList.add('hit');
        hit.removeAttribute('marker-start'); hit.removeAttribute('marker-mid'); hit.removeAttribute('marker-end');
        g.appendChild(hit); // on top for clicks
      });
    });

    // --- index elements for search ---
    const nameToId = new Map();
    function addName(id, text){ const key=normalizeId(text); if(key) nameToId.set(key, id); }
    [...elemGroups, ...clusterGroups].forEach(g => {
      addName(g.id, g.id);
      const t=g.querySelector('text'); if(t) addName(g.id, t.textContent||'');
    });

    function setViewToBBox(b){
      const pad = Math.max(b.width, b.height) * 0.4 || 20;
      const nx = b.x - pad, ny = b.y - pad;
      const nw = b.width + pad*2, nh = b.height + pad*2;
      const aspect = state.vb.width / state.vb.height;
      let tw = nw, th = nh;
      if (nw / nh > aspect) th = nw / aspect; else tw = nh * aspect;
      state.vb = { x: nx - (tw - nw)/2, y: ny - (th - nh)/2, width: tw, height: th };
      setViewBox(svgRoot, state.vb);
    }

    function clearHighlight() {
      [...allNodeGroups, ...linkGroups].forEach(g => g.classList.remove('is-node-highlight','is-link-highlight','is-dimmed'));
    }
    function setDimmed(dim) {
      const cls='is-dimmed';
      [...allNodeGroups, ...linkGroups].forEach(g => g.classList.toggle(cls, dim));
    }
    function undimWithAncestors(node){
      let n = node;
      while (n && n !== n.ownerSVGElement) {
        if (n.classList && n.classList.contains('is-dimmed')) n.classList.remove('is-dimmed');
        n = n.parentElement;
      }
    }

    function highlightFor(targetId) {
      const isCluster = targetId.startsWith('cluster_');
      let nodeTokens, clusterElems=[];
      const elemBBox = new Map(), clusterBBox = new Map();
      elemGroups.forEach(g => { try{ elemBBox.set(g, g.getBBox()); }catch{} });
      clusterGroups.forEach(g => { try{ clusterBBox.set(g, g.getBBox()); }catch{} });

      // map cluster -> elements inside
      const clusterInfo = new Map();
      const INSIDE_PADDING = 2;
      clusterGroups.forEach(cluster => {
        const cb = clusterBBox.get(cluster);
        const insideElems = [];
        if (cb) {
          elemGroups.forEach(el => {
            const eb = elemBBox.get(el);
            if (eb && bboxContains(cb, eb, INSIDE_PADDING)) insideElems.push(el);
          });
        }
        const tokenSet = new Set(insideElems.map(g => normalizeId(g.id)));
        clusterInfo.set(cluster.id, { elems: insideElems, tokens: tokenSet });
      });

      if (isCluster) {
        const info = clusterInfo.get(targetId) || { elems: [], tokens: new Set() };
        nodeTokens = Array.from(info.tokens);
        clusterElems = info.elems;
      } else {
        nodeTokens = [normalizeId(targetId)];
      }

      const connectedLinks = linkGroups.filter(link => {
        try { return JSON.parse(link.dataset.tokens||'[]').some(t => nodeTokens.includes(t)); } catch { return false; }
      });
      const connectedNodeTokens = new Set();
      connectedLinks.forEach(link => { try { JSON.parse(link.dataset.tokens||'[]').forEach(t => connectedNodeTokens.add(t)); } catch {} });

      allNodeGroups.forEach(g => g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g => g.classList.remove('is-link-highlight'));
      setDimmed(true);

      const hovered = allNodeGroups.find(g => g.id === targetId);
      if (hovered) { hovered.classList.add('is-node-highlight'); undimWithAncestors(hovered); }
      if (isCluster) clusterElems.forEach(el => { el.classList.add('is-node-highlight'); undimWithAncestors(el); });
      connectedLinks.forEach(g => { g.classList.add('is-link-highlight'); undimWithAncestors(g); });
      elemGroups.forEach(g => { if (connectedNodeTokens.has(normalizeId(g.id))) undimWithAncestors(g); });

      try {
        const node = [...elemGroups, ...clusterGroups].find(x => x.id === targetId);
        if (node) setViewToBBox(node.getBBox());
      } catch {}
    }

    function highlightLink(linkId) {
      let toks=[]; try{ toks=JSON.parse(svgDoc.getElementById(linkId)?.dataset.tokens||'[]'); }catch{}
      const tokenSet=new Set(toks);
      const everything=[...elemGroups, ...clusterGroups, ...linkGroups];

      everything.forEach(g=>g.classList.add('is-dimmed'));
      elemGroups.forEach(g=>g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g=>g.classList.remove('is-link-highlight'));

      const link=svgDoc.getElementById(linkId);
      if(link){ link.classList.add('is-link-highlight'); undimWithAncestors(link); }

      elemGroups.forEach(g=>{
        if(tokenSet.has(normalizeId(g.id))){
          g.classList.add('is-node-highlight');
          undimWithAncestors(g);
        }
      });
    }

    // ====== Click wiring using movement threshold ======
    allNodeGroups.forEach(g => {
      g.addEventListener('click', () => {
        if (movedPx > DRAG_THRESHOLD) return;
        highlightFor(g.id);
      });
    });
    linkGroups.forEach(g => {
      g.addEventListener('click', (e) => {
        if (movedPx > DRAG_THRESHOLD) return;
        e.stopPropagation();
        highlightLink(g.id);
      });
    });
    svgDoc.addEventListener('click', (e) => {
      if (movedPx > DRAG_THRESHOLD) return;
      if (e.target === svgDoc || e.target === svgRoot) clearHighlight();
    });

    // ====== Search wiring ======
    function focusAndHighlight(targetId){ highlightFor(targetId); }
    const searchBox = document.getElementById('searchBox');
    function runSearch(q){
      const key = normalizeId(q); if(!key) return;
      let target = nameToId.get(key);
      if(!target){ const pref=[...nameToId.keys()].find(k=>k.startsWith(key)); if(pref) target=nameToId.get(pref); }
      if(!target){ const cont=[...nameToId.keys()].find(k=>k.includes(key)); if(cont) target=nameToId.get(cont); }
      if(target) focusAndHighlight(target);
    }
    searchBox.addEventListener('keydown', (e)=>{ if(e.key==='Enter') runSearch(searchBox.value); });
    searchBox.addEventListener('input', (e)=>{ if(e.target.value.length>=3) runSearch(e.target.value); });
    const suggestions=new Set();
    [...elemGroups, ...clusterGroups].forEach(g=>{
      const label=(g.querySelector('text')?.textContent || g.id.replace(/^elem_|^cluster_/,'')).trim();
      if(label) suggestions.add(label);
    });
    [...elemGroups, ...clusterGroups].forEach(g => suggestions.add(g.id));
    const dl=document.getElementById('graphTerms');
    dl.innerHTML=[...suggestions].sort((a,b)=>a.localeCompare(b)).map(s=>`<option value="${s}">`).join('');

    // ====== Left buttons for top-level clusters ======
    const pkgPanel = document.getElementById('pkgPanel');
    const clearBtn = document.getElementById('clearPkgBtn');
    clearBtn.addEventListener('click', () => {
      clearHighlight();
      pkgPanel.querySelectorAll('.pkgbtn').forEach(b => b.classList.remove('is-active'));
    });

    const topLevelClusters = clusterGroups.filter(g => !g.parentElement.closest('g[id^="cluster_"]'));
    function labelForCluster(g){ return g.querySelector('text')?.textContent?.trim() || g.id.replace(/^cluster_/,''); }
    topLevelClusters.forEach(cl => {
      const btn = document.createElement('button');
      btn.className = 'pkgbtn';
      btn.textContent = labelForCluster(cl);
      btn.dataset.targetId = cl.id;
      btn.title = `Highlight ${btn.textContent}`;
      btn.addEventListener('click', () => {
        pkgPanel.querySelectorAll('.pkgbtn').forEach(b => b.classList.remove('is-active'));
        btn.classList.add('is-active');
        focusAndHighlight(cl.id);
      });
      pkgPanel.appendChild(btn);
    });

    console.info('SVG pan/zoom initialized. viewBox=', state.vb);
  });

  svgObj.addEventListener('error', () => {
    console.error('Failed to load UML_ontology.svg. Check path and server.');
  });
  </script>
</body>
</html>
