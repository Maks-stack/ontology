<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SVG Highlighter — elements & packages</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    .wrap { display: grid; gap: 12px; }
    .note { font-size: 14px; opacity: .85; padding: 8px 10px; background:#f7f7f7; border:1px solid #e5e5e5; border-radius:8px; }
    .toolbar {
      position: fixed; right: 18px; bottom: 18px;
      display: grid; gap: 8px; z-index: 9999;
    }
    .toolbtn {
      border: 1px solid #ccc; background: #fff;
      padding: 8px 10px; border-radius: 8px; font: inherit; cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }
    .toolbtn:active { transform: translateY(1px); }
    .is-grab { cursor: grab; }
    .is-grabbing { cursor: grabbing; }
    object, object:focus { touch-action: none; }
    html, body { user-select: none; -webkit-user-select: none; }

    .pkgbar {
      position: fixed; left: 18px; top: 18px;
      display: grid; gap: 6px; z-index: 9999;
      max-height: calc(100vh - 36px); overflow: auto; padding-right: 4px; margin-top: 200px;
    }
    .pkgbtn {
      border: 1px solid #ccc; background: #fff; padding: 6px 10px;
      border-radius: 8px; font: 13px system-ui, sans-serif; cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.08); text-align: left;
      max-width: 200px;
    }
    .pkgbtn:active { transform: translateY(1px); }
    .pkgbtn.is-active { border-color: #4b9cff; box-shadow: 0 0 0 2px rgba(75,156,255,.2); }
  </style>
</head>
<body>
  <div class="pkgbar" id="pkgPanel">
    <button class="pkgbtn" id="clearPkgBtn" title="Clear highlight">Clear</button>
  </div>

  <div class="wrap" style="margin-left: 200px;">
    <h1>Highlight and select elements</h1>

    <!-- Dynamic per-selection text lives here -->
    <div id="noteBox" class="note"></div>

    <div style="display: flex; gap: 8px; align-items: center;">
      <input id="searchBox" list="graphTerms" placeholder="Search element…"
         style="margin-left:auto; padding:6px 8px; border:1px solid #ccc; border-radius:8px; min-width:240px;">
      <datalist id="graphTerms"></datalist>

      <!-- Single diagram picker -->
      <select id="diagramPicker" style="padding:6px 8px; border:1px solid #ccc; border-radius:8px;">
        <!-- options populated by JS -->
      </select>
    </div>

    <object id="svgObj" type="image/svg+xml" data="./UML_ontology.svg"
            width="100%" style="border:1px solid #ccc; max-height: 80vh;"></object>
  </div>

  <div class="toolbar" aria-label="Zoom controls">
    <button class="toolbtn" id="zoomInBtn"  title="Zoom in ( + )">+</button>
    <button class="toolbtn" id="zoomOutBtn" title="Zoom out ( – )">−</button>
    <button class="toolbtn" id="resetBtn"   title="Reset view ( 0 )">Reset</button>
  </div>

  <script>
  // ====== Helpers ======
  function normalizeId(str) {
    return (str || '').replace(/^elem_/,'').replace(/^link_/,'').replace(/^cluster_/,'')
      .toLowerCase().replace(/[^a-z0-9]+/g,'');
  }
  function tokensFromId(id) { return (id || '').split(/_to_|_/).map(normalizeId).filter(Boolean); }
  function bboxContains(outer, inner, padding = 0) {
    return (inner.x >= outer.x - padding &&
            inner.y >= outer.y - padding &&
            inner.x + inner.width  <= outer.x + outer.width  + padding &&
            inner.y + inner.height <= outer.y + outer.height + padding);
  }

  // ====== Pan/zoom utilities ======
  function unionContentBBox(svg) {
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity, any=false;
    svg.querySelectorAll('*').forEach(node=>{
      if (node instanceof SVGGraphicsElement && typeof node.getBBox==='function') {
        try{
          const b=node.getBBox();
          if([b.x,b.y,b.width,b.height].every(Number.isFinite)){
            minX=Math.min(minX,b.x); minY=Math.min(minY,b.y);
            maxX=Math.max(maxX,b.x+b.width); maxY=Math.max(maxY,b.y+b.height);
            any=true;
          }
        }catch{}
      }
    });
    if(!any) return null;
    return { x:minX, y:minY, width:Math.max(1,maxX-minX), height:Math.max(1,maxY-minY) };
  }
  function ensureViewBox(svg){
    const vb = svg.viewBox && svg.viewBox.baseVal;
    if (vb && vb.width>0 && vb.height>0) return { x:vb.x, y:vb.y, width:vb.width, height:vb.height };
    const u=unionContentBBox(svg);
    if(u){ svg.setAttribute('viewBox', `${u.x} ${u.y} ${u.width} ${u.height}`); return u; }
    const w=parseFloat(svg.getAttribute('width'))||100, h=parseFloat(svg.getAttribute('height'))||100;
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`); return { x:0, y:0, width:w, height:h };
  }
  function setViewBox(svg, vb){ svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`); }
  function clientPointToSvg(svg, clientX, clientY){
    const pt=svg.createSVGPoint(); pt.x=clientX; pt.y=clientY;
    const ctm=svg.getScreenCTM(); if(!ctm) return {x:0,y:0};
    const p=pt.matrixTransform(ctm.inverse()); return { x:p.x, y:p.y };
  }
  function zoomAt(svg, state, center, factor){
    const { vb0, vb } = state;
    const newW = vb.width * factor;
    const minW = vb0.width / 10, maxW = vb0.width * 5;
    const clampedW = Math.min(Math.max(newW, minW), maxW);
    const scaleAdj = clampedW / vb.width;
    const newH = vb.height * scaleAdj;
    const sx = (center.x - vb.x) / vb.width;
    const sy = (center.y - vb.y) / vb.height;
    vb.x = center.x - sx * clampedW;
    vb.y = center.y - sy * newH;
    vb.width = clampedW;
    vb.height = newH;
    setViewBox(svg, vb);
  }
  function panBy(svg, state, dx, dy){ state.vb.x += dx; state.vb.y += dy; setViewBox(svg, state.vb); }

  // ====== Globals for UI ======
  const svgObj   = document.getElementById('svgObj');
  const pkgPanel = document.getElementById('pkgPanel');
  const clearBtn = document.getElementById('clearPkgBtn');
  const searchBox = document.getElementById('searchBox');
  const datalist = document.getElementById('graphTerms');
  const picker = document.getElementById('diagramPicker');
  const noteBox = document.getElementById('noteBox');

  // ====== Diagram switching with per-selection custom text ======
  const DIAGRAMS = [
    {
      label:'Ontology',
      path:'./master.svg',
      note:`<strong>Ontology:</strong> 
      Core semantic classes and relations. Use to reason about domain structure.<br>
      Packages:<br>
      <strong>Metrics:</strong> capture quantifiable user data from events.<br>
      <strong>KeySituations:</strong> significant vents triggering relevant key situations. One or more events combined can trigger a KeySituation.<br>
      <strong>AssistantActions:</strong> actions taken by the assistant in response to KeySituations, informed by Metrics and UserModel. Can contain state of mechanics, user messages<br>
      <strong>KeySituations:</strong> significant Situations triggered by events. Play an important role for user motivation and usage flow.<br>
      <strong>Plan_and_Tasks:</strong> user plans and tasks assigned. Mark a planned progression for the user. Might be shared by Personal Development app and Motivational Assistant.<br>
      <strong>UserModel</strong>: representation of the user with connections to traits, state, metrics, and assigned tasks.<br>
      <strong>User Traits</strong>: motivational or personality traits of the user.<br>
      <strong>Motivational Mechanics</strong>: mechanics applied to motivate the user, selected based on trait-mechanic mappings.<br><br>
      `
    },
    {
      label:'Instances',
      path:'./UML_ontology_instances.svg',
      note:`<strong>Instances:</strong> <br><br>
      This diagram shows concrete instances for user U123 on 2025-09-15.<br><br>

      EventRegistration records two events (session started, task finished) and one event collection window with counts and duration.<br>
      Events trigger KeySituations for session start and task completion.<br><br>

      Metrics capture adherence for the user and usage rate for the Level/XP mechanic.<br>
      The event collection aggregates into adherence and summarizes the session-start situation.<br><br>

      <strong>AssistantActions</strong> fire from the key situations: a welcome prompt at 08:12, a demographics form at 08:30, and an IMI survey at 09:00.<br>
      These actions affect the UserModel, the IMI produces a metric, considers the user’s Player trait weight and the Player↔Level/XP mapping, and can toggle the Level/XP mechanic.<br><br>

      UserModel holds the user instance and their Player trait weight (0.75) and owns a plan with a week-38 block and a Memory Game assignment with requirements (reps and level).<br><br>

      Mappings link traits to mechanics with weights, e.g., Player→Level/XP (0.8) and Socializer→Community Insights (0.8).<br><br>

      Net effect: events → situations → actions → user and metrics, with trait-mechanic mappings guiding which mechanics get reinforced or toggled.`
    },
    {
      label:'High Level Ontology',
      path:'./master_highlevel.svg',
      note:`
      <strong>High Level Overview :</strong> <br><br>
      EventRegistration records occurrences in the system or user context and converts them into Metrics that quantify user activity. It can also initiate KeySituations, which represent contextually significant events requiring motivational handling.<br><br>
      KeySituations activate AssistantActions, which constitute the assistant’s responses such as prompts, feedback, or adaptive interventions. These actions are informed by Metrics and the UserModel to ensure contextual relevance and are used to adjust or toggle specific MotivationalMechanics (e.g., rewards, goals, feedback loops).<br><br>
      MotivationalMechanics are selected per user based on mappings between UserTraits (individual motivational or personality attributes) and mechanics with the highest predicted effectiveness. These mappings are represented in Usertrait_Mechanic_Mapping.<br><br>
      The UserModel functions as the central representation of the individual, encompassing their state, traits, metrics, and assigned tasks. It maintains continuous reference to and synchronization with these components, completing the adaptive feedback loop between user behavior, system observation, and personalized motivation.`
    },
    {
      label:'Architecture',
      path:'./Architecture.svg',
      note:`<strong>Architecture:</strong> <br><br>
        The User interacts with the main system through the UI Layer. In the diagram the Personal Development applications UI and the Motivational Assistants UI are seperated, while in practice the code might be mixed.<br><br>

        The Personal Development UI communicates directly with the Personal Development model as they are very tighly coupled. We assume that the Personal Development UI, the Personal Development Logic and a Domain model containing some data about the user and their progress already exists as a whole application. <br><br>

        The Motivational Assistant UI and its logic are added on top of the already existing application so they must be more loosely coupled.
        For that reason an Adapter pattern is used to connect the Motivational Assistant to the main system. In the adapter Events like Session Started, Task finished are defined. The Motivational Assistan UI can call these events to notify the Motivational Assistant Logic about the users actions. These events are received by the Motivational Assistants logic and processed. The Motivational Assistants Logic then updates the Domain Model with new Metrics and new user States.<br><br>
        We can see that the Domain Model contains some parts that are shared between the Personal Development application and the Motivational Assistant like the User Model, Tasks and Plans. These parts are used by both systems.<br><br>
        Some other parts specific to the Motivatonal Assistant like events, metrics and  mechanic mappings are not shared.<br><br>
        The Motivational Assistant Logic then sends back Assistan Actions via the Action Mapper in the Adapter which the Motivational Assistant UI can receive and then convert them into UI changes, activation or deactivation of mechanics etc.
        `


    }
  ];

  function setDiagram(path){
    localStorage.setItem('umlDiagramPath', path);

    // set per-selection text
    const meta = DIAGRAMS.find(d => d.path === path);
    noteBox.innerHTML = meta?.note || '';

    // reset UI tied to previous SVG
    [...pkgPanel.querySelectorAll('.pkgbtn')].forEach(b => { if (b !== clearBtn) b.remove(); });
    datalist.innerHTML = '';
    searchBox.value = '';

    // load svg
    svgObj.data = path;

    // sync picker
    if (picker && [...picker.options].some(o => o.value === path)) picker.value = path;
  }

  function initPicker(){
    picker.innerHTML = DIAGRAMS.map(d=>`<option value="${d.path}">${d.label}</option>`).join('');
    const saved = localStorage.getItem('umlDiagramPath');
    const initial = saved && DIAGRAMS.some(d=>d.path===saved) ? saved : DIAGRAMS[0].path;
    picker.value = initial;
    setDiagram(initial);
  }
  picker.addEventListener('change', ()=> setDiagram(picker.value));
  initPicker();

  // ====== Main loader per-diagram ======
  svgObj.addEventListener('load', () => {
    const svgDoc  = svgObj.contentDocument;
    if (!svgDoc) { console.warn('SVG contentDocument not available.'); return; }
    const svgRoot = svgDoc.documentElement;
    if (!svgRoot || svgRoot.nodeName.toLowerCase() !== 'svg') { console.warn('Embedded doc is not <svg>.'); return; }

    // safety: wipe buttons on reload except Clear
    [...pkgPanel.querySelectorAll('.pkgbtn')].forEach(b => { if (b !== clearBtn) b.remove(); });

    svgRoot.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    svgRoot.style.touchAction = 'none';
    svgRoot.style.userSelect = 'none';
    svgRoot.style.webkitUserSelect = 'none';

    // Init pan/zoom state
    const vbInit = ensureViewBox(svgRoot);
    const state = { vb0: { ...vbInit }, vb:  { ...vbInit } };

    // ====== Wheel zoom ======
    let wheelFrame = null, wheelAccum = 0, lastWheelCenter = null;
    function normalizeDeltaY(e){ if(e.deltaMode===1)return e.deltaY*16; if(e.deltaMode===2)return e.deltaY*800; return e.deltaY; }
    const ZOOM_SENS = 0.0015;
    function onWheelSmooth(e){
      e.preventDefault(); e.stopPropagation();
      lastWheelCenter = clientPointToSvg(svgRoot, e.clientX, e.clientY);
      wheelAccum += normalizeDeltaY(e);
      if(!wheelFrame){
        wheelFrame = requestAnimationFrame(()=>{
          zoomAt(svgRoot, state, lastWheelCenter, Math.exp(ZOOM_SENS*wheelAccum));
          wheelAccum=0; wheelFrame=null;
        });
      }
    }
    svgRoot.addEventListener('wheel', onWheelSmooth, { passive: false });

    // ====== Drag to pan with click/drag separation ======
    svgRoot.classList.add('is-grab');
    let isDragging=false, pointerId=null, lastClientX=0, lastClientY=0, panDX=0, panDY=0, panFrame=null;
    let movedPx=0; const DRAG_THRESHOLD=5;

    function flushPan(){
      panFrame=null;
      if(!isDragging || (panDX===0 && panDY===0)) return;
      const rect=svgRoot.getBoundingClientRect();
      const sx=state.vb.width/rect.width, sy=state.vb.height/rect.height;
      const dxSVG=panDX*sx, dySVG=panDY*sy;
      panDX=0; panDY=0; panBy(svgRoot, state, -dxSVG, -dySVG);
    }
    function onPointerDown(e){
      if(e.button!==undefined && e.button!==0) return;
      e.preventDefault();
      pointerId=e.pointerId; isDragging=true; movedPx=0;
      lastClientX=e.clientX; lastClientY=e.clientY;
      svgRoot.classList.remove('is-grab'); svgRoot.classList.add('is-grabbing');
      try{(e.target.setPointerCapture||svgRoot.setPointerCapture)?.call(e.target,e.pointerId);}catch{}
    }
    function onPointerMove(e){
      if(!isDragging || (pointerId!==null && e.pointerId!==pointerId)) return;
      const dx=e.clientX-lastClientX; const dy=e.clientY-lastClientY;
      lastClientX=e.clientX; lastClientY=e.clientY;
      movedPx += Math.hypot(dx,dy);
      panDX+=dx; panDY+=dy;
      if(!panFrame){ panFrame=requestAnimationFrame(flushPan); }
    }
    function onPointerUpOrCancel(e){
      if(!isDragging || (pointerId!==null && e.pointerId!==pointerId)) return;
      isDragging=false; pointerId=null; flushPan();
      svgRoot.classList.remove('is-grabbing'); svgRoot.classList.add('is-grab');
      try{(e.target.releasePointerCapture||svgRoot.releasePointerCapture)?.call(e.target,e.pointerId);}catch{}
    }
    svgRoot.addEventListener('pointerdown', onPointerDown, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointermove', onPointerMove, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointerup', onPointerUpOrCancel, { passive:false });
    svgRoot.ownerDocument.addEventListener('pointercancel', onPointerUpOrCancel, { passive:false });

    // ====== Keyboard shortcuts ======
    svgRoot.ownerDocument.addEventListener('keydown', (e) => {
      if (e.key === '+' || e.key === '=') {
        const r=svgRoot.getBoundingClientRect(); const c=clientPointToSvg(svgRoot,r.left+r.width/2,r.top+r.height/2);
        zoomAt(svgRoot, state, c, 1/1.1);
      } else if (e.key === '-') {
        const r=svgRoot.getBoundingClientRect(); const c=clientPointToSvg(svgRoot,r.left+r.width/2,r.top+r.height/2);
        zoomAt(svgRoot, state, c, 1.1);
      } else if (e.key === '0') {
        state.vb = { ...state.vb0 }; setViewBox(svgRoot, state.vb);
      }
    });

    // ====== Injected styles for highlighting ======
    const style = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `
      svg { touch-action:none; user-select:none; -webkit-user-select:none; }
      .is-dimmed { opacity:.4; transition:opacity .12s; }

      .is-node-highlight rect,
      .is-node-highlight path,
      .is-node-highlight polygon {
        stroke:#000 !important;
        stroke-width:3 !important;
      }

      .is-link-highlight path:not(.hit),
      .is-link-highlight line:not(.hit),
      .is-link-highlight polyline:not(.hit) {
        stroke:#000 !important;
        stroke-width:2.5 !important;
      }

      .is-node-highlight text {
        font-weight:700;
        paint-order:stroke;
        stroke:#fff;
        stroke-width:1.5;
        stroke-opacity:.9;
      }

      g[id^="elem_"], g[id^="cluster_"] { cursor: pointer; }

      /* Oversized invisible hit geometry for links */
      g[id^="link_"] .hit {
        stroke:#000; stroke-opacity:0.001; stroke-width:300;
        fill:none; vector-effect:non-scaling-stroke; pointer-events: stroke; cursor: pointer;
      }
      g[id^="link_"] path:not(.hit),
      g[id^="link_"] line:not(.hit),
      g[id^="link_"] polyline:not(.hit),
      g[id^="link_"] polygon:not(.hit) { pointer-events: none; }
    `;
    svgRoot.appendChild(style);

    // ====== Highlight logic ======
    const elemGroups    = Array.from(svgDoc.querySelectorAll('g[id^="elem_"]'));
    const clusterGroups = Array.from(svgDoc.querySelectorAll('g[id^="cluster_"]'));
    const linkGroups    = Array.from(svgDoc.querySelectorAll('g[id^="link_"]'));
    const allNodeGroups = [...elemGroups, ...clusterGroups];

    // Build hit geometry for all link primitives
    linkGroups.forEach(g => g.dataset.tokens = JSON.stringify(tokensFromId(g.id)));
    linkGroups.forEach(g => {
      g.querySelectorAll('path,line,polyline,polygon').forEach(el => {
        const hit = el.cloneNode(false);
        hit.classList.add('hit');
        hit.removeAttribute('marker-start'); hit.removeAttribute('marker-mid'); hit.removeAttribute('marker-end');
        g.appendChild(hit);
      });
    });

    // --- index elements for search ---
    const nameToId = new Map();
    function addName(id, text){ const key=normalizeId(text); if(key) nameToId.set(key, id); }
    [...elemGroups, ...clusterGroups].forEach(g => {
      addName(g.id, g.id);
      const t=g.querySelector('text'); if(t) addName(g.id, t.textContent||'');
    });

    function setViewToBBox(b){
      const pad = Math.max(b.width, b.height) * 0.4 || 20;
      const nx = b.x - pad, ny = b.y - pad;
      const nw = b.width + pad*2, nh = b.height + pad*2;
      const aspect = state.vb.width / state.vb.height;
      let tw = nw, th = nh;
      if (nw / nh > aspect) th = nw / aspect; else tw = nh * aspect;
      state.vb = { x: nx - (tw - nw)/2, y: ny - (th - nh)/2, width: tw, height: th };
      setViewBox(svgRoot, state.vb);
    }

    function clearHighlight() {
      [...allNodeGroups, ...linkGroups].forEach(g => g.classList.remove('is-node-highlight','is-link-highlight','is-dimmed'));
    }
    function setDimmed(dim) {
      const cls='is-dimmed';
      [...allNodeGroups, ...linkGroups].forEach(g => g.classList.toggle(cls, dim));
    }
    function undimWithAncestors(node){
      let n = node;
      while (n && n !== n.ownerSVGElement) {
        if (n.classList && n.classList.contains('is-dimmed')) n.classList.remove('is-dimmed');
        n = n.parentElement;
      }
    }

    function highlightFor(targetId) {
      const isCluster = targetId.startsWith('cluster_');
      let nodeTokens, clusterElems=[];
      const elemBBox = new Map(), clusterBBox = new Map();
      elemGroups.forEach(g => { try{ elemBBox.set(g, g.getBBox()); }catch{} });
      clusterGroups.forEach(g => { try{ clusterBBox.set(g, g.getBBox()); }catch{} });

      // map cluster -> elements inside
      const clusterInfo = new Map();
      const INSIDE_PADDING = 2;
      clusterGroups.forEach(cluster => {
        const cb = clusterBBox.get(cluster);
        const insideElems = [];
        if (cb) {
          elemGroups.forEach(el => {
            const eb = elemBBox.get(el);
            if (eb && bboxContains(cb, eb, INSIDE_PADDING)) insideElems.push(el);
          });
        }
        const tokenSet = new Set(insideElems.map(g => normalizeId(g.id)));
        clusterInfo.set(cluster.id, { elems: insideElems, tokens: tokenSet });
      });

      if (isCluster) {
        const info = clusterInfo.get(targetId) || { elems: [], tokens: new Set() };
        nodeTokens = Array.from(info.tokens);
        clusterElems = info.elems;
      } else {
        nodeTokens = [normalizeId(targetId)];
      }

      const connectedLinks = linkGroups.filter(link => {
        try { return JSON.parse(link.dataset.tokens||'[]').some(t => nodeTokens.includes(t)); } catch { return false; }
      });
      const connectedNodeTokens = new Set();
      connectedLinks.forEach(link => { try { JSON.parse(link.dataset.tokens||'[]').forEach(t => connectedNodeTokens.add(t)); } catch {} });

      allNodeGroups.forEach(g => g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g => g.classList.remove('is-link-highlight'));
      setDimmed(true);

      const hovered = allNodeGroups.find(g => g.id === targetId);
      if (hovered) { hovered.classList.add('is-node-highlight'); undimWithAncestors(hovered); }
      if (isCluster) clusterElems.forEach(el => { el.classList.add('is-node-highlight'); undimWithAncestors(el); });
      connectedLinks.forEach(g => { g.classList.add('is-link-highlight'); undimWithAncestors(g); });
      elemGroups.forEach(g => { if (connectedNodeTokens.has(normalizeId(g.id))) undimWithAncestors(g); });

      try {
        const node = [...elemGroups, ...clusterGroups].find(x => x.id === targetId);
        if (node) setViewToBBox(node.getBBox());
      } catch {}
    }

    function highlightLink(linkId) {
      let toks=[]; try{ toks=JSON.parse(svgDoc.getElementById(linkId)?.dataset.tokens||'[]'); }catch{}
      const tokenSet=new Set(toks);
      const everything=[...elemGroups, ...clusterGroups, ...linkGroups];

      everything.forEach(g=>g.classList.add('is-dimmed'));
      elemGroups.forEach(g=>g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g=>g.classList.remove('is-link-highlight'));

      const link=svgDoc.getElementById(linkId);
      if(link){ link.classList.add('is-link-highlight'); undimWithAncestors(link); }

      elemGroups.forEach(g=>{
        if(tokenSet.has(normalizeId(g.id))){
          g.classList.add('is-node-highlight');
          undimWithAncestors(g);
        }
      });
    }

    // ====== Click wiring using movement threshold ======
    allNodeGroups.forEach(g => {
      g.addEventListener('click', () => {
        if (movedPx > DRAG_THRESHOLD) return;
        highlightFor(g.id);
      });
    });
    linkGroups.forEach(g => {
      g.addEventListener('click', (e) => {
        if (movedPx > DRAG_THRESHOLD) return;
        e.stopPropagation();
        highlightLink(g.id);
      });
    });
    svgDoc.addEventListener('click', (e) => {
      if (movedPx > DRAG_THRESHOLD) return;
      if (e.target === svgDoc || e.target === svgRoot) clearHighlight();
    });

    // ====== Search wiring ======
    function focusAndHighlight(targetId){ highlightFor(targetId); }
    function runSearch(q){
      const key = normalizeId(q); if(!key) return;
      let target = nameToId.get(key);
      if(!target){ const pref=[...nameToId.keys()].find(k=>k.startsWith(key)); if(pref) target=nameToId.get(pref); }
      if(!target){ const cont=[...nameToId.keys()].find(k=>k.includes(key)); if(cont) target=nameToId.get(cont); }
      if(target) focusAndHighlight(target);
    }
    searchBox.addEventListener('keydown', (e)=>{ if(e.key==='Enter') runSearch(searchBox.value); });
    searchBox.addEventListener('input', (e)=>{ if(e.target.value.length>=3) runSearch(e.target.value); });
    const suggestions=new Set();
    [...elemGroups, ...clusterGroups].forEach(g=>{
      const label=(g.querySelector('text')?.textContent || g.id.replace(/^elem_|^cluster_/,'')).trim();
      if(label) suggestions.add(label);
    });
    [...elemGroups, ...clusterGroups].forEach(g => suggestions.add(g.id));
    datalist.innerHTML=[...suggestions].sort((a,b)=>a.localeCompare(b)).map(s=>`<option value="${s}">`).join('');

    // ====== Left buttons for top-level clusters ======
    clearBtn.addEventListener('click', () => {
      clearHighlight();
      pkgPanel.querySelectorAll('.pkgbtn').forEach(b => b.classList.remove('is-active'));
    });

    const topLevelClusters = clusterGroups.filter(g => !g.parentElement.closest('g[id^="cluster_"]'));
    function labelForCluster(g){ return g.querySelector('text')?.textContent?.trim() || g.id.replace(/^cluster_/,''); }
    topLevelClusters.forEach(cl => {
      const btn = document.createElement('button');
      btn.className = 'pkgbtn';
      btn.textContent = labelForCluster(cl);
      btn.dataset.targetId = cl.id;
      btn.title = `Highlight ${btn.textContent}`;
      btn.addEventListener('click', () => {
        pkgPanel.querySelectorAll('.pkgbtn').forEach(b => b.classList.remove('is-active'));
        btn.classList.add('is-active');
        focusAndHighlight(cl.id);
      });
      pkgPanel.appendChild(btn);
    });

    console.info('SVG pan/zoom initialized. viewBox=', state.vb, 'diagram=', svgObj.data);
  });

  svgObj.addEventListener('error', () => {
    console.error('Failed to load SVG:', svgObj.data);
  });
  </script>
</body>
</html>
