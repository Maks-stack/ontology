<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SVG Highlighter — elements & packages</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 24px; }
    .wrap { display: grid; gap: 12px; }
    .note { font-size: 14px; opacity: .8; }
    .toolbar {
      position: fixed;
      right: 18px;
      bottom: 18px;
      display: grid;
      gap: 8px;
      z-index: 9999;
    }
    .toolbtn {
      border: 1px solid #ccc;
      background: #fff;
      padding: 8px 10px;
      border-radius: 8px;
      font: inherit;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,.08);
    }
    .toolbtn:active { transform: translateY(1px); }
    .is-grab { cursor: grab; }
    .is-grabbing { cursor: grabbing; }
    /* Let us handle gestures on touch */
    object, object:focus { touch-action: none; }
    /* Kill text selection while dragging */
    html, body { user-select: none; -webkit-user-select: none; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Hover to highlight connections (elements + packages)</h1>
    <div class="note">
      - Hover an element to highlight its connected links.<br/>
      - Hover a package to highlight <em>every element visually inside it</em> and <em>all</em> connections of those elements.<br/>
      - Scroll to zoom (smooth), drag to pan, double-click to zoom in, use the buttons to reset.
    </div>
    <object id="svgObj" type="image/svg+xml" data="./UML_ontology.svg"
            width="100%" style="border:1px solid #ccc; max-height: 80vh;"></object>
  </div>

  <!-- Zoom controls -->
  <div class="toolbar" aria-label="Zoom controls">
    <button class="toolbtn" id="zoomInBtn"  title="Zoom in ( + )">+</button>
    <button class="toolbtn" id="zoomOutBtn" title="Zoom out ( – )">−</button>
    <button class="toolbtn" id="resetBtn"   title="Reset view ( 0 )">Reset</button>
  </div>

  <script>
  // ====== Helpers ======
  function normalizeId(str) {
    return (str || '')
      .replace(/^elem_/, '')
      .replace(/^link_/, '')
      .replace(/^cluster_/, '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g,'');
  }
  function tokensFromId(id) {
    return (id || '').split(/_to_|_/).map(normalizeId).filter(Boolean);
  }
  function bboxContains(outer, inner, padding = 0) {
    return (
      inner.x >= outer.x - padding &&
      inner.y >= outer.y - padding &&
      inner.x + inner.width  <= outer.x + outer.width  + padding &&
      inner.y + inner.height <= outer.y + outer.height + padding
    );
  }

  // ====== Pan/zoom utilities ======
  function unionContentBBox(svg) {
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity, any = false;
    svg.querySelectorAll('*').forEach(node => {
      if (node instanceof SVGGraphicsElement && typeof node.getBBox === 'function') {
        try {
          const b = node.getBBox();
          if (isFinite(b.x) && isFinite(b.y) && isFinite(b.width) && isFinite(b.height)) {
            minX = Math.min(minX, b.x);
            minY = Math.min(minY, b.y);
            maxX = Math.max(maxX, b.x + b.width);
            maxY = Math.max(maxY, b.y + b.height);
            any = true;
          }
        } catch {}
      }
    });
    if (!any) return null;
    return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
  }

  function ensureViewBox(svg) {
    const vb = svg.viewBox && svg.viewBox.baseVal;
    if (vb && vb.width > 0 && vb.height > 0) {
      return { x: vb.x, y: vb.y, width: vb.width, height: vb.height };
    }
    const u = unionContentBBox(svg);
    if (u) {
      svg.setAttribute('viewBox', `${u.x} ${u.y} ${u.width} ${u.height}`);
      return u;
    }
    const w = parseFloat(svg.getAttribute('width'))  || 100;
    const h = parseFloat(svg.getAttribute('height')) || 100;
    svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
    return { x: 0, y: 0, width: w, height: h };
  }
  function setViewBox(svg, vb) {
    svg.setAttribute('viewBox', `${vb.x} ${vb.y} ${vb.width} ${vb.height}`);
  }
  function clientPointToSvg(svg, clientX, clientY) {
    const pt = svg.createSVGPoint();
    pt.x = clientX; pt.y = clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) return { x: 0, y: 0 };
    const inv = ctm.inverse();
    const p = pt.matrixTransform(inv);
    return { x: p.x, y: p.y };
  }
  function zoomAt(svg, state, center, factor) {
    const { vb0, vb } = state;
    const newW = vb.width * factor;
    const minW = vb0.width / 10; // 10× in
    const maxW = vb0.width * 5;  // 5× out
    const clampedW = Math.min(Math.max(newW, minW), maxW);
    const scaleAdj = clampedW / vb.width;
    const newH = vb.height * scaleAdj;

    const sx = (center.x - vb.x) / vb.width;
    const sy = (center.y - vb.y) / vb.height;

    vb.x = center.x - sx * clampedW;
    vb.y = center.y - sy * newH;
    vb.width = clampedW;
    vb.height = newH;
    setViewBox(svg, vb);
  }
  function panBy(svg, state, dx, dy) {
    state.vb.x += dx;
    state.vb.y += dy;
    setViewBox(svg, state.vb);
  }

  const svgObj = document.getElementById('svgObj');

  svgObj.addEventListener('load', () => {
    const svgDoc  = svgObj.contentDocument;
    if (!svgDoc) { console.warn('SVG contentDocument not available.'); return; }
    const svgRoot = svgDoc.documentElement;
    if (!svgRoot || svgRoot.nodeName.toLowerCase() !== 'svg') { console.warn('Embedded doc is not <svg>.'); return; }

    svgRoot.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    svgRoot.style.touchAction = 'none';
    svgRoot.style.userSelect = 'none';
    svgRoot.style.webkitUserSelect = 'none';

    // Init pan/zoom state
    const vbInit = ensureViewBox(svgRoot);
    const state = {
      vb0: { ...vbInit },
      vb:  { ...vbInit }
    };

    // ====== Jitter-free wheel zoom (rAF + normalization) ======
    let wheelFrame = null;
    let wheelAccum = 0;
    let lastWheelCenter = null;

    function normalizeDeltaY(e) {
      if (e.deltaMode === 1) return e.deltaY * 16;
      if (e.deltaMode === 2) return e.deltaY * 800;
      return e.deltaY;
    }
    const ZOOM_SENS = 0.0015;

    function onWheelSmooth(e) {
      e.preventDefault();
      e.stopPropagation();
      lastWheelCenter = clientPointToSvg(svgRoot, e.clientX, e.clientY);
      wheelAccum += normalizeDeltaY(e);
      if (!wheelFrame) {
        wheelFrame = requestAnimationFrame(() => {
          const factor = Math.exp(ZOOM_SENS * wheelAccum);
          zoomAt(svgRoot, state, lastWheelCenter, factor);
          wheelAccum = 0;
          wheelFrame = null;
        });
      }
    }
    svgRoot.addEventListener('wheel', onWheelSmooth, { passive: false });

    // ====== Double-click to zoom in ======
    svgRoot.addEventListener('dblclick', (e) => {
      e.preventDefault();
      const pt = clientPointToSvg(svgRoot, e.clientX, e.clientY);
      zoomAt(svgRoot, state, pt, 1/1.5);
    });

    // ====== Drag to pan — rAF-coalesced, measured in SCREEN space ======
    svgRoot.classList.add('is-grab');

    let isDragging = false;
    let pointerId = null;
    let lastClientX = 0, lastClientY = 0;
    let panDX = 0, panDY = 0;     // accumulated screen-space delta
    let panFrame = null;

    function flushPan() {
      panFrame = null;
      if (!isDragging || (panDX === 0 && panDY === 0)) return;

      // Convert screen-space pixels to SVG units using current viewBox scale
      const rect = svgRoot.getBoundingClientRect();
      const sx = state.vb.width  / rect.width;   // svg units per CSS px
      const sy = state.vb.height / rect.height;

      const dxSVG = panDX * sx;
      const dySVG = panDY * sy;

      panDX = 0; panDY = 0;
      panBy(svgRoot, state, -dxSVG, -dySVG); // negative because dragging moves content opposite pointer
    }

    function onPointerDown(e) {
      if (e.button !== undefined && e.button !== 0) return; // left mouse only
      e.preventDefault();
      pointerId = e.pointerId;
      isDragging = true;
      lastClientX = e.clientX;
      lastClientY = e.clientY;
      svgRoot.classList.remove('is-grab');
      svgRoot.classList.add('is-grabbing');
      try { (e.target.setPointerCapture || svgRoot.setPointerCapture)?.call(e.target, e.pointerId); } catch {}
    }

    function onPointerMove(e) {
      if (!isDragging || (pointerId !== null && e.pointerId !== pointerId)) return;
      // Accumulate *screen* deltas to avoid CTM feedback jitter
      const dx = e.clientX - lastClientX;
      const dy = e.clientY - lastClientY;
      lastClientX = e.clientX;
      lastClientY = e.clientY;
      panDX += dx;
      panDY += dy;

      if (!panFrame) {
        panFrame = requestAnimationFrame(flushPan);
      }
    }

    function onPointerUpOrCancel(e) {
      if (!isDragging || (pointerId !== null && e.pointerId !== pointerId)) return;
      isDragging = false;
      pointerId = null;
      flushPan();
      svgRoot.classList.remove('is-grabbing');
      svgRoot.classList.add('is-grab');
      try { (e.target.releasePointerCapture || svgRoot.releasePointerCapture)?.call(e.target, e.pointerId); } catch {}
    }

    svgRoot.addEventListener('pointerdown', onPointerDown, { passive: false });
    svgRoot.ownerDocument.addEventListener('pointermove', onPointerMove, { passive: false });
    svgRoot.ownerDocument.addEventListener('pointerup', onPointerUpOrCancel, { passive: false });
    svgRoot.ownerDocument.addEventListener('pointercancel', onPointerUpOrCancel, { passive: false });

    // ====== Keyboard shortcuts ======
    svgRoot.ownerDocument.addEventListener('keydown', (e) => {
      if (e.key === '+') {
        const r = svgRoot.getBoundingClientRect();
        const c = clientPointToSvg(svgRoot, r.left + r.width/2, r.top + r.height/2);
        zoomAt(svgRoot, state, c, 1/1.1);
      } else if (e.key === '-') {
        const r = svgRoot.getBoundingClientRect();
        const c = clientPointToSvg(svgRoot, r.left + r.width/2, r.top + r.height/2);
        zoomAt(svgRoot, state, c, 1.1);
      } else if (e.key === '0') {
        state.vb = { ...state.vb0 };
        setViewBox(svgRoot, state.vb);
      }
    });

    // ====== Buttons ======
    const zoomInBtn  = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const resetBtn   = document.getElementById('resetBtn');
    function zoomAtCenter(factor) {
      const r = svgRoot.getBoundingClientRect();
      const c = clientPointToSvg(svgRoot, r.left + r.width/2, r.top + r.height/2);
      zoomAt(svgRoot, state, c, factor);
    }
    zoomInBtn.addEventListener('click',  () => zoomAtCenter(1/1.1));
    zoomOutBtn.addEventListener('click', () => zoomAtCenter(1.1));
    resetBtn.addEventListener('click',   () => { state.vb = { ...state.vb0 }; setViewBox(svgRoot, state.vb); });

    // ====== Injected styles for highlighting ======
    const style = svgDoc.createElementNS('http://www.w3.org/2000/svg', 'style');
    style.textContent = `
      svg { touch-action: none; user-select: none; -webkit-user-select: none; }
      .is-node-highlight rect, .is-node-highlight path, .is-node-highlight polygon {
        stroke-width: 3 !important;
        filter: saturate(1.1);
      }
      .is-link-highlight path, .is-link-highlight line, .is-link-highlight polygon {
        stroke-width: 3 !important;
      }
      .is-dimmed { opacity: .2; transition: opacity .15s; }
      g[id^="elem_"], g[id^="cluster_"] { cursor: pointer; }
    `;
    svgRoot.appendChild(style);

    // ====== Highlight logic ======
    const elemGroups    = Array.from(svgDoc.querySelectorAll('g[id^="elem_"]'));
    const clusterGroups = Array.from(svgDoc.querySelectorAll('g[id^="cluster_"]'));
    const linkGroups    = Array.from(svgDoc.querySelectorAll('g[id^="link_"]'));
    const allNodeGroups = [...elemGroups, ...clusterGroups];

    linkGroups.forEach(g => g.dataset.tokens = JSON.stringify(tokensFromId(g.id)));

    const elemBBox = new Map();
    const clusterBBox = new Map();
    elemGroups.forEach(g => { try { elemBBox.set(g, g.getBBox()); } catch {} });
    clusterGroups.forEach(g => { try { clusterBBox.set(g, g.getBBox()); } catch {} });

    const clusterInfo = new Map();
    const INSIDE_PADDING = 2;
    clusterGroups.forEach(cluster => {
      const cb = clusterBBox.get(cluster);
      const insideElems = [];
      if (cb) {
        elemGroups.forEach(el => {
          const eb = elemBBox.get(el);
          if (eb && bboxContains(cb, eb, INSIDE_PADDING)) insideElems.push(el);
        });
      }
      const tokenSet = new Set(insideElems.map(g => normalizeId(g.id)));
      clusterInfo.set(cluster.id, { elems: insideElems, tokens: tokenSet });
    });

    function setDimmed(dim) {
      const cls = 'is-dimmed';
      [...allNodeGroups, ...linkGroups].forEach(g => g.classList.toggle(cls, dim));
    }
    function clearHighlight() {
      setDimmed(false);
      allNodeGroups.forEach(g => g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g => g.classList.remove('is-link-highlight'));
    }
    function highlightFor(targetId) {
      const isCluster = targetId.startsWith('cluster_');
      let nodeTokens;
      let clusterElems = [];

      if (isCluster) {
        const info = clusterInfo.get(targetId) || { elems: [], tokens: new Set() };
        nodeTokens = Array.from(info.tokens);
        clusterElems = info.elems;
      } else {
        nodeTokens = [normalizeId(targetId)];
      }

      const connectedLinks = linkGroups.filter(link => {
        try {
          const toks = JSON.parse(link.dataset.tokens || '[]');
          return toks.some(t => nodeTokens.includes(t));
        } catch { return false; }
      });

      const connectedNodeTokens = new Set();
      connectedLinks.forEach(link => {
        try { JSON.parse(link.dataset.tokens || '[]').forEach(t => connectedNodeTokens.add(t)); } catch {}
      });

      allNodeGroups.forEach(g => g.classList.remove('is-node-highlight'));
      linkGroups.forEach(g => g.classList.remove('is-link-highlight'));
      setDimmed(true);

      const hovered = allNodeGroups.find(g => g.id === targetId);
      if (hovered) hovered.classList.add('is-node-highlight');

      if (isCluster) {
        clusterElems.forEach(el => el.classList.add('is-node-highlight'));
      }

      connectedLinks.forEach(g => g.classList.add('is-link-highlight'));

      if (hovered) hovered.classList.remove('is-dimmed');

      if (isCluster) {
        clusterElems.forEach(el => el.classList.remove('is-dimmed'));
      }

      elemGroups.forEach(g => {
        if (connectedNodeTokens.has(normalizeId(g.id))) g.classList.remove('is-dimmed');
      });

      clusterGroups.forEach(cluster => {
        const info = clusterInfo.get(cluster.id) || { tokens: new Set() };
        for (const t of connectedNodeTokens) {
          if (info.tokens.has(t)) { cluster.classList.remove('is-dimmed'); break; }
        }
      });

      connectedLinks.forEach(g => g.classList.remove('is-dimmed'));
    }

    allNodeGroups.forEach(g => {
      g.addEventListener('mouseenter', () => highlightFor(g.id));
      g.addEventListener('mouseleave', clearHighlight);
    });

    console.info('SVG pan/zoom initialized. viewBox=', state.vb);
  });

  // Basic load error feedback
  svgObj.addEventListener('error', () => {
    console.error('Failed to load UML_ontology.svg. Check path and server.');
  });
  </script>
</body>
</html>
