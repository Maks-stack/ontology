@startuml

skinparam linetype polyline

package Metrics_and_Measurements {

  class Metric {
    +id: int
    +userId: int
    +timestamp: DateTime
    +value: float
  }

  class MetricComputation {
    +algorithm: String
  }

  MetricComputation --> Metric : "produces"

  Measurement <-- MetricComputation : "reads"

  object MechanicUsageRate
  MechanicUsageRate : MetricÂ´
  MechanicUsageRate : userId = 1
  MechanicUsageRate : timestamp = 2023-10-01T12:00:00Z
  MechanicUsageRate --> Metric : "instance of"

  object MechanicDisplayRate
  MechanicDisplayRate : MetricÂ´
  MechanicDisplayRate : userId = 1
  MechanicDisplayRate : timestamp = 2023-10-01T12:00:00Z
  MechanicDisplayRate --> Metric : "instance of"

  object MechanicEngagement
  MechanicEngagement : MetricÂ´
  MechanicEngagement : userId = 1
  MechanicEngagement : timestamp = 2023-10-01T12:00:00Z
  MechanicEngagement --> Metric : "instance of"

  object SessionDuration
  SessionDuration : userId = 1
  SessionDuration : mechanicId = 101
  SessionDuration : impressionCount = 2
  SessionDuration : timestamp = 2025-04-21T09:00:00Z
  SessionDuration --> Metric : "instance of"

  object ClickRate
  ClickRate : userId = 1
  ClickRate : mechanicId = 101
  ClickRate : impressionCount = 2
  ClickRate : timestamp = 2025-04-21T09:00:00Z
  ClickRate --> Metric : "intance of"

  object Adherence
  Adherence : Metric
  Adherence : userId = 1
  Adherence : timestamp = 2023-10-01T12:00:00Z
  Adherence --> Metric : "instance of"

  note as A1
  Percentage of the finished tasks out of the overall prescribed tasks
  end note

  A1 .. Adherence

  class Measurement {
    +id: int
    +userId: int
    +timestamp: DateTime
    +measurementType: MeasurementType
    +value: float
  }

  note top of Measurement
  Represents a direct, single-point observation 
  or quantitative recording of user behavior or 
  state at a given moment in time.

  Examples:
  - Click rate
  - Session duration
  - Number of impressions
  end note

  object mechanicImpression
  mechanicImpression : Measurement
  mechanicImpression : userId = 1
  mechanicImpression : mechanicId = 101
  mechanicImpression : impressionCount = 5
  mechanicImpression : timestamp = 2025-04-21T09:00:00Z

  mechanicImpression ---> Measurement :"instance of"

  note bottom of mechanicImpression
  Captures a one-time measurement of how often
  a specific motivational mechanic was shown or visible 
  to the user at a given point in time.
  Used to support decisions on reinforcing or deactivating it.
  end note

  object Time
  Time : userId = 1
  Time : mechanicId = 101
  Time : impressionCount = 2
  Time : timestamp = 2025-04-21T09:00:00Z
  Time --> Measurement : "instance of"

  ' ðŸ”µ Interaction Object
  object mechanicInteraction
  mechanicInteraction : userId = 1
  mechanicInteraction : mechanicId = 101
  mechanicInteraction : impressionCount = 2
  mechanicInteraction : timestamp = 2025-04-21T09:00:00Z

  mechanicInteraction --> Measurement : "instance of"

  note bottom of mechanicInteraction
  Captures a one-time measurement of how often
  a specific motivational mechanic was used or interacted with 
  by the user at a specific moment.
  Helps evaluate the effectiveness of mechanic engagement.
  end note
}

package KeySituations {

  class MeasurementType {
    +id: int
    +name: String
  }

  note top of MeasurementType
  Represents the type or category of a measurement.
  Examples: Click rate, session duration, etc.
  end note

  Measurement --> MeasurementType : "is of type"

class KeySituation {
  +id: int
  +userId: int
  +timestamp: DateTime
  +mechanicId: int
  +screen: String
  +value: float
  +metadata: Map<String, String>
}

object TaskFinished
TaskFinished : KeySituation
TaskFinished : userId = 1
TaskFinished : timestamp = 2023-10-01T12:00:00Z
TaskFinished : taskId = 123
TaskFinished --> KeySituation : "instance of"

object MechanicDisplayed
MechanicDisplayed : KeySituation
MechanicDisplayed : userId = 1
MechanicDisplayed : timestamp = 2023-10-01T12:00:00Z
MechanicDisplayed : taskId = 123
MechanicDisplayed --> KeySituation : "instance of"

object MechanicInteraction
MechanicInteraction : KeySituation
MechanicInteraction : userId = 1
MechanicInteraction : timestamp = 2023-10-01T12:00:00Z
MechanicInteraction : taskId = 123
MechanicInteraction --> KeySituation : "instance of"

object SessionStarted
SessionStarted : KeySituation
SessionStarted : userId = 1
SessionStarted : timestamp = 2023-10-01T12:00:00Z
SessionStarted : taskId = 123
SessionStarted --> KeySituation : "instance of"

object TaskStarted
TaskStarted : KeySituation
TaskStarted : userId = 1
TaskStarted : timestamp = 2023-10-01T12:00:00Z
TaskStarted : taskId = 123
TaskStarted --> KeySituation : "instance of"

object TaskEnded
TaskEnded : KeySituation
TaskEnded : userId = 1
TaskEnded : timestamp = 2023-10-01T12:00:00Z
TaskEnded : taskId = 123
TaskEnded --> KeySituation : "instance of"

object SessionEnded
SessionEnded : KeySituation
SessionEnded : userId = 1
SessionEnded : timestamp = 2023-10-01T12:00:00Z
SessionEnded : taskId = 123
SessionEnded --> KeySituation : "instance of"

note left of KeySituation
Generic KeySituation structure used for multiple behavioral logs,
such as screen visits, mechanic usage, and session tracking.
end note

}

package Interventions {
  class Intervention {
    +id: int
    +userId: int
    +timestamp: DateTime
    +screen: String
    +metadata: Map<String, String>
  }

  note right of Intervention
  Represents a planned activity, stimulus, or interaction
  aimed at influencing user behavior or collecting data.
  Examples: questionnaires, prompts, mini-games, etc.
  end note

  class Questionnaire {
    +questionCount: int
    +estimatedTime: int
  }

  Questionnaire --> Intervention : "instance of"
  Intervention --> KeySituation : "triggered by"

  object MorningMoodCheck
  MorningMoodCheck : Questionnaire
  MorningMoodCheck : id = 1
  MorningMoodCheck : name = "Morning Mood Check"
  MorningMoodCheck : description = "Daily check-in on user's mood"
  MorningMoodCheck : questionCount = 5
  MorningMoodCheck : estimatedTime = 3
  MorningMoodCheck --> Questionnaire : "instance of"

  class MotivationalMessage #cdeaff {
    +id: int
    +text: String
    +targetState: MotivationalStates
  }
  
  MotivationalMessage --> Intervention : "instance of"

  MotivationalMessage --> MotivationalState : "selected based on"
  MotivationalMessage --> KeySituation : "shown during"

  object MotivationalMessagePM_LOW
  MotivationalMessagePM_LOW : MotivationalMessage
  MotivationalMessagePM_LOW : userId = 1
  MotivationalMessagePM_LOW --> MotivationalMessage : "instance of"
}

package UserActions{

  class UserAction {
    +id: int
    +userId: int
    +timestamp: DateTime
    +screen: String
    +metadata: Map<String, String>
  }

  object Action {
    +userId: int
    +timestamp: DateTime
    +screen: String
    +metadata: Map<String, String>
  } 
  Action : UserAction
  Action --> UserAction : "instance of"


  object Click {
    +userId: int
    +timestamp: DateTime
    +screen: String
    +metadata: Map<String, String>
  } 
  Click : UserAction
  Click --> UserAction : "instance of"

  UserAction --> KeySituation : "triggers"
  KeySituation --> Measurement : "triggers"
  Measurement --> Metric : "triggers"

}

package Program_and_Tasks {

  abstract class ITaskComponent #lightyellow {
    +getId(): int
    +getTitle(): String
    +getDescription(): String
  }

  class Program #lightgreen {
    +id: int
    +name: String
    +description: String
  }

  note right of Program
  A succession of task blocks (composites).
  end note

  class Task #lightblue {
    +id: int
    +title: String
    +description: String
    +isMandatory: Boolean
    +completed: Boolean
  }

  class Level #lightgreen {
    +id: int
    +name: String
    +difficulty: Int
    +unlocked: Boolean
  }

  class Repetitions #lightgreen {
    +id: int
    +count: Int
    +completed: Boolean
  }

  note bottom of Level
  Indicates the difficulty of a task. Optional as task might not have difficulty.
  end note

  note bottom of Repetitions
  Indicates the number of repetitions of a task. Mandatory to define program.
  end note

  class TaskRequirement #lightblue {
    +requiredRepetitions: int
  }

  note left of TaskRequirement
  How many times a Task must be repeated
  on a specific Level within a TaskBlock.
  end note

  class TaskAssignment #lightblue {
    task: Task
    inplements ITaskComponent
  }

  note right of TaskAssignment
  Assigns a Task to a TaskBlock and defines
  required repetitions across Levels.
  end note

  class TaskBlock #lightgreen {
    +id: int
    +title: String
    +description: String
    +startDate: DateTime
    +endDate: DateTime
    +children: List<ITaskComponent>
    inplements ITaskComponent
  }

  note right of TaskBlock
  Composite element: groups multiple TaskAssignments and TaskBlocks
  into a hierarchy. Allows nested structures.
  end note

  ' Inheritance for Composite structure
  ITaskComponent <|-- TaskAssignment
  ITaskComponent <|-- TaskBlock

  TaskAssignment --> "1" Task : assigned
  TaskAssignment --> "1..*" TaskRequirement
  TaskRequirement --> "0..1" Level : optional
  TaskRequirement --> "1..*" Repetitions : required

  Program --> "1..*" TaskBlock
  TaskBlock --> "0..*" ITaskComponent : contains

}

package User_and_UserTraits {

  class User #f59bff {
    +id: int
    +UserTraitWeights: List<UserTraitWeight>
  }

  User --> Program : "has assigned"
  User --> UserAction : "performs"

  class UserTrait {
    +id: int
    +name: string
  }
  together {
    class MotivationalTrait extends UserTrait
    note bottom of MotivationalTrait
    MotivationalTrait is a representation of a user's motivational characteristics.
    end note

    class PlayerType extends UserTrait
    note bottom of PlayerType
    Playertype is a representation of a user's gaming style or approach.
    end note

    class DigitalLiteracy extends UserTrait
    note bottom of DigitalLiteracy
    Describes a user's familiarity and comfort with digital technologies,
    including software tools, navigation, and basic troubleshooting.
    end note

    class CognitiveAbility extends UserTrait
    note bottom of CognitiveAbility
    Represents a user's capacity for logical reasoning, memory, and 
    problem-solving. Important for adapting the complexity of tasks.
    end note

    class AttentionSpan extends UserTrait
    note bottom of AttentionSpan
    Describes the user's ability to maintain focus over time. 
    Useful for pacing content and avoiding cognitive overload.
    end note

    class SelfDiscipline extends UserTrait
    note bottom of SelfDiscipline
    Indicates the user's ability to stay consistent, resist distractions, 
    and complete tasks independently.
    end note

    object FrustrationTolerance
    FrustrationTolerance : UserTrait
    FrustrationTolerance : userId = 1
    FrustrationTolerance --> UserTrait : "instance of"

    note bottom of FrustrationTolerance
    Measures how well a user copes with difficulty, failure, or delay. 
    Helpful for adjusting challenge levels and support mechanisms.
    end note
  }

  class UserTraitWeight #f59bff {
    +trait: UserTrait
    +weight: float  ' (0.0 â€“ 1.0) '
  }

  User --> "0..*" UserTraitWeight : "has"
  UserTraitWeight --> UserTrait : "references"

  class UserTraitWeight #f59bff{
    +userId: int
    +traitId: int
    +userTrait: UserTrait
    +weight: float  ' (0.0 â€“ 1.0) '
  }
}

package MotivationalState_and_CognitiveLoadState {

  class MotivationalState { 
    - state: MotivationalStates
    + isHigh(): boolean
    + isMedium(): boolean
    + isLow(): boolean
  }

  MotivationalState --> Metric : "calculated from"
  MotivationalState --> Program : "calculated from"

  object Low
  Low : MotivationalState
  Low : userId = 1
  Low --> MotivationalState : "instance of"

  object Medium
  Medium : MotivationalState
  Medium : userId = 1
  Medium --> MotivationalState : "instance of"

  object High
  High : MotivationalState
  High : userId = 1
  High --> MotivationalState : "instance of"


  class CognitiveLoadState {
  }

  CognitiveLoadState --> Metric : "calculated from"

  object UnderchallengedState
  UnderchallengedState : CognitiveLoadState
  UnderchallengedState : userId = 1
  UnderchallengedState --> CognitiveLoadState : "instance of"

  object OptimalLoadState
  OptimalLoadState : CognitiveLoadState
  OptimalLoadState : userId = 1
  OptimalLoadState --> CognitiveLoadState : "instance of"

  object OverloadedState
  OverloadedState : CognitiveLoadState
  OverloadedState : userId = 1
  OverloadedState --> CognitiveLoadState : "instance of"
}

package Usertrait_Mechanic_Mapping {

  class MotivationalMechanic #9bfbff {
  +mechanicId: int
  +name: string
  +description: string
  +isActive(): boolean
  +mechanicTraitWeights: List<MechanicTraitWeight>
}

MotivationalMechanic --> CognitiveLoadState : "activated based on"

class MechanicTraitWeight #9bfbff {
  +mechanicId: int
  +userTrait: UserTrait
  +weight: float  ' (0.0 â€“ 1.0) '
}

MotivationalMechanic --> "1..*" MechanicTraitWeight : "has"
  
  class SocialMechanic extends MotivationalMechanic {
    +socialMechanicId: int
  }
  class LeaderBoardMechanic extends SocialMechanic{
  }
  object ProgramAdherenceLeaderboard
  ProgramAdherenceLeaderboard : LeaderBoardMechanic
  ProgramAdherenceLeaderboard : weights = [ProgramAdherenceLeaderboardToPersonal_MasteryMapping]
  ProgramAdherenceLeaderboard --> LeaderBoardMechanic : "instance of"

  object PerformanceLeaderboard
  PerformanceLeaderboard : LeaderBoardMechanic
  PerformanceLeaderboard : weights = [PerformanceLeaderboardToPersonal_MasteryMapping]
  PerformanceLeaderboard --> LeaderBoardMechanic : "instance of"

  class CommunityInsights extends SocialMechanic {
  
  }

  class ChallengeMechanic extends MotivationalMechanic {
    +challengeMechanicId: int
  }

  object Wager
  Wager : ChallengeMechanic
  Wager : weights = [WagerToPersonal_MasteryMapping]
  Wager --> ChallengeMechanic : "instance of"

  object Streak
  Streak : ChallengeMechanic
  Streak : weights = [StreakToPersonal_MasteryMapping]
  Streak --> ChallengeMechanic : "instance of"

  class Mapping {
    Trait : UserTrait
    Mechanic: MotivationalMechanic
    weight: float
  }
  Mapping --> UserTrait : "has"
  Mapping --> MotivationalMechanic : "references"

  MotivationalMechanic --> Mapping: "selected based on"

  object ProgramAdherenceLeaderboardToPersonal_MasteryMapping {
    Trait = Personal_Mastery
    Mechanic = ProgramAdherenceLeaderboard
    weight = 0.4
  }
  ProgramAdherenceLeaderboardToPersonal_MasteryMapping : Mapping
  ProgramAdherenceLeaderboardToPersonal_MasteryMapping --> Mapping : "instance of"

  object PerformanceLeaderboardToPersonal_MasteryMapping {
    Trait = Personal_Mastery
    Mechanic = PerformanceLeaderboard
    weight = 0.7
  }
  PerformanceLeaderboardToPersonal_MasteryMapping : Mapping
  PerformanceLeaderboardToPersonal_MasteryMapping --> Mapping : "instance of"

  object WagerToPersonal_MasteryMapping {
    Trait = Personal_Mastery
    Mechanic = Wager
    weight = 1
  }
  WagerToPersonal_MasteryMapping : Mapping
  WagerToPersonal_MasteryMapping --> Mapping : "instance of"

  object StreakToPersonal_MasteryMapping {
    Trait = Personal_Mastery
    Mechanic = Streak
    weight = 0.9
  }
  StreakToPersonal_MasteryMapping : Mapping
  StreakToPersonal_MasteryMapping --> Mapping : "instance of"
}

@enduml7
