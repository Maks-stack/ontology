@startuml

skinparam linetype polyline

package Metrics_and_Measurements {

  class Metric {
    +id: int
    +userId: int
    +timestamp: DateTime
    +value: float
  }

  class MetricComputation {
    +algorithm: String
  }

  MetricComputation --> Metric : "produces"

  Measurement <-- MetricComputation : "reads"

  object MechanicUsageRate
  MechanicUsageRate : MetricÂ´
  MechanicUsageRate : userId = 1
  MechanicUsageRate : timestamp = 2023-10-01T12:00:00Z
  MechanicUsageRate --> Metric : "instance of"

  object MechanicDisplayRate
  MechanicDisplayRate : MetricÂ´
  MechanicDisplayRate : userId = 1
  MechanicDisplayRate : timestamp = 2023-10-01T12:00:00Z
  MechanicDisplayRate --> Metric : "instance of"

  object MechanicEngagement
  MechanicEngagement : MetricÂ´
  MechanicEngagement : userId = 1
  MechanicEngagement : timestamp = 2023-10-01T12:00:00Z
  MechanicEngagement --> Metric : "instance of"

  object SessionDuration
  SessionDuration : userId = 1
  SessionDuration : mechanicId = 101
  SessionDuration : impressionCount = 2
  SessionDuration : timestamp = 2025-04-21T09:00:00Z
  SessionDuration --> Metric : "incance of"

  object ClickRate
  ClickRate : userId = 1
  ClickRate : mechanicId = 101
  ClickRate : impressionCount = 2
  ClickRate : timestamp = 2025-04-21T09:00:00Z
  ClickRate --> Metric : "incance of"

  object Adherence
  Adherence : Metric
  Adherence : userId = 1
  Adherence : timestamp = 2023-10-01T12:00:00Z
  Adherence --> Metric : "instance of"

  note as A1
  Percentage of the finished tasks out of the overall prescribed tasks
  end note

  A1 .. Adherence

  class Measurement {
    +id: int
    +userId: int
    +timestamp: DateTime
    +measurementType: MeasurementType
    +value: float
  }

  note top of Measurement
  Represents a direct, single-point observation 
  or quantitative recording of user behavior or 
  state at a given moment in time.

  Examples:
  - Click rate
  - Session duration
  - Number of impressions
  end note

  object mechanicImpression
  mechanicImpression : Measurement
  mechanicImpression : userId = 1
  mechanicImpression : mechanicId = 101
  mechanicImpression : impressionCount = 5
  mechanicImpression : timestamp = 2025-04-21T09:00:00Z

  mechanicImpression ---> Measurement :"instance of"

  note bottom of mechanicImpression
  Captures a one-time measurement of how often
  a specific motivational mechanic was shown or visible 
  to the user at a given point in time.
  Used to support decisions on reinforcing or deactivating it.
  end note

  object Time
  Time : userId = 1
  Time : mechanicId = 101
  Time : impressionCount = 2
  Time : timestamp = 2025-04-21T09:00:00Z
  Time --> Measurement : "incance of"

  ' ðŸ”µ Interaction Object
  object mechanicInteraction
  mechanicInteraction : userId = 1
  mechanicInteraction : mechanicId = 101
  mechanicInteraction : impressionCount = 2
  mechanicInteraction : timestamp = 2025-04-21T09:00:00Z

  mechanicInteraction --> Measurement : "instance of"

  note bottom of mechanicInteraction
  Captures a one-time measurement of how often
  a specific motivational mechanic was used or interacted with 
  by the user at a specific moment.
  Helps evaluate the effectiveness of mechanic engagement.
  end note
}

package KeySituations_and_UserActions {

  class MeasurementType {
    +id: int
    +name: String
  }

  note top of MeasurementType
  Represents the type or category of a measurement.
  Examples: Click rate, session duration, etc.
  end note

  Measurement --> MeasurementType : "is of type"

class KeySituation {
  +id: int
  +userId: int
  +timestamp: DateTime
  +mechanicId: int
  +screen: String
  +value: float
  +metadata: Map<String, String>
}

object TaskFinished
TaskFinished : KeySituation
TaskFinished : userId = 1
TaskFinished : timestamp = 2023-10-01T12:00:00Z
TaskFinished : taskId = 123
TaskFinished --> KeySituation : "instance of"

object MechanicDisplayed
MechanicDisplayed : KeySituation
MechanicDisplayed : userId = 1
MechanicDisplayed : timestamp = 2023-10-01T12:00:00Z
MechanicDisplayed : taskId = 123
MechanicDisplayed --> KeySituation : "instance of"

object MechanicInteraction
MechanicInteraction : KeySituation
MechanicInteraction : userId = 1
MechanicInteraction : timestamp = 2023-10-01T12:00:00Z
MechanicInteraction : taskId = 123
MechanicInteraction --> KeySituation : "instance of"

object SessionStarted
SessionStarted : KeySituation
SessionStarted : userId = 1
SessionStarted : timestamp = 2023-10-01T12:00:00Z
SessionStarted : taskId = 123
SessionStarted --> KeySituation : "instance of"

object SessionEnded
SessionEnded : KeySituation
SessionEnded : userId = 1
SessionEnded : timestamp = 2023-10-01T12:00:00Z
SessionEnded : taskId = 123
SessionEnded --> KeySituation : "instance of"

note left of KeySituation
Generic KeySituation structure used for multiple behavioral logs,
such as screen visits, mechanic usage, and session tracking.
end note

class UserAction {
  +id: int
  +userId: int
  +timestamp: DateTime
  +screen: String
  +metadata: Map<String, String>
}

object Action {
  +userId: int
  +timestamp: DateTime
  +screen: String
  +metadata: Map<String, String>
} 
Action : UserAction
Action --> UserAction : "instance of"


object Click {
  +userId: int
  +timestamp: DateTime
  +screen: String
  +metadata: Map<String, String>
} 
Click : UserAction
Click --> UserAction : "instance of"

UserAction --> KeySituation : "triggers"
KeySituation --> Measurement : "triggers"
Measurement --> Metric : "triggers"

}

package Program_and_Tasks {

  class Program #lightgreen{
    +id: int
    +name: String
    +description: String
  }

  note right of Program
  A succession of tasks blocks. 
  end note


  class Task #lightgreen{
    +id: int
    +title: String
    +description: String
    +isMandatory: Boolean
    +completed: Boolean
  }
  class Level #lightgreen {
    +id: int
    +name: String
    +difficulty: Int
    +unlocked: Boolean
  }
  class Repetitions #lightgreen {
    +id: int
    +count: Int
    +completed: Boolean
  }
  note bottom of Level
  Indicates the difficulty of a task. Optional as task might not have difficulty.
  end note

  note bottom of Repetitions
  Indicates the mumber of repetitions of a task. Mandatory to define program.
  end note
  class TaskBlock #lightgreen {
    +id: int
    +title: String
    +description: String
    +startDate: DateTime
    +endDate: DateTime
    +taskAssignments: List<TaskAssignment>
  }

  ' ðŸ”„ Defines required repetitions per level'
  class TaskRequirement #lightgreen {
    +requiredRepetitions: int
  }
  note left of TaskRequirement
  How many times a Task must be repeated
  on a specific Level within a TaskBlock.
  end note

  note right of TaskBlock
  A timeframe that defines a number of tasks to be finished 
  at a certain level during a specified duration time. 
  Defined by date and time.
  end note

  ' Links a Task to a set of Level requirements within a TaskBlock '
  class TaskAssignment #lightgreen{
    task: Task
  }
  note right of TaskAssignment
  Assigns a Task to a TaskBlock and defines
  required repetitions across Levels.
  end note

  TaskAssignment --> "1..1" Task : "assigned task"
  TaskAssignment --> "1..*" TaskRequirement
  TaskRequirement --> "0..1" Level : "optional difficulty level"
  TaskRequirement --> "1..*" Repetitions : "mandatory number of repetitions"

  TaskBlock --> "1..*" TaskAssignment
  Program --> "1..*" TaskBlock
}

package User_and_UserTraits {

  class User #f59bff {
    +id: int
    +UserTraitWeights: List<UserTraitWeight>
  }

  User --> Program : "has assigned"
  User --> UserAction : "performs"

  class UserTrait {
    +id: int
    +name: string
  }
  together {
    class MotivationalTrait extends UserTrait
    note bottom of MotivationalTrait
    MotivationalTrait is a representation of a user's motivational characteristics.
    end note

    class PlayerType extends UserTrait
    note bottom of PlayerType
    Playertype is a representation of a user's gaming style or approach.
    end note

    class DigitalLiteracy extends UserTrait
    note bottom of DigitalLiteracy
    Describes a user's familiarity and comfort with digital technologies,
    including software tools, navigation, and basic troubleshooting.
    end note

    class CognitiveAbility extends UserTrait
    note bottom of CognitiveAbility
    Represents a user's capacity for logical reasoning, memory, and 
    problem-solving. Important for adapting the complexity of tasks.
    end note

    class AttentionSpan extends UserTrait
    note bottom of AttentionSpan
    Describes the user's ability to maintain focus over time. 
    Useful for pacing content and avoiding cognitive overload.
    end note

    class SelfDiscipline extends UserTrait
    note bottom of SelfDiscipline
    Indicates the user's ability to stay consistent, resist distractions, 
    and complete tasks independently.
    end note

    object FrustrationTolerance
    FrustrationTolerance : UserTrait
    FrustrationTolerance : userId = 1
    FrustrationTolerance --> UserTrait : "instance of"

    note bottom of FrustrationTolerance
    Measures how well a user copes with difficulty, failure, or delay. 
    Helpful for adjusting challenge levels and support mechanisms.
    end note
  }

  class UserTraitWeight #f59bff {
    +trait: UserTrait
    +weight: float  ' (0.0 â€“ 1.0) '
  }

  User --> "0..*" UserTraitWeight : "has"
  UserTraitWeight --> UserTrait : "references"

  class UserTraitWeight #f59bff{
    +userId: int
    +traitId: int
    +userTrait: UserTrait
    +weight: float  ' (0.0 â€“ 1.0) '
  }
}



enum MotivationalStates #9bfbff { 
  LOW
  MEDIUM
  HIGH
}

class MotivationalState #9bfbff { 
  - state: MotivationalStates
  + isHigh(): boolean
  + isMedium(): boolean
  + isLow(): boolean
}


CurrentMotivationalState --> MotivationalStates

class CognitiveLoadState {
}

object UnderchallengedState
UnderchallengedState : CognitiveLoadState
UnderchallengedState : userId = 1
UnderchallengedState --> CognitiveLoadState : "instance of"

object OptimalLoadState
OptimalLoadState : CognitiveLoadState
OptimalLoadState : userId = 1
OptimalLoadState --> CognitiveLoadState : "instance of"

object OverloadedState
OverloadedState : CognitiveLoadState
OverloadedState : userId = 1
OverloadedState --> CognitiveLoadState : "instance of"

note as MOTIVATION_VS_LOAD
**CurrentMotivationalState** vs. **CognitiveLoadState**

*CurrentMotivationalState*: 
Describes the user's **inner drive or engagement** (motivation level).
Values: LOW, MEDIUM, HIGH.

*CognitiveLoadState*: 
Reflects the user's **mental workload or task burden**.
Values: UNDERCHALLENGED, OPTIMAL, OVERLOADED.

Together, they shape adaptive decisions:
- High Motivation + Overloaded â†’ lighten tasks
- Low Motivation + Underchallenged â†’ introduce rewards or stimulation
end note

class MotivationalMessage #cdeaff {
  +id: int
  +text: String
  +targetState: MotivationalStates
}

MotivationalMessage --> MotivationalStates : "selected based on"



package Usertrait_Mechanic_Mapping {

  class MotivationalMechanic #9bfbff {
  +mechanicId: int
  +name: string
  +description: string
  +isActive(): boolean
  +mechanicTraitWeights: List<MechanicTraitWeight>
}

class MechanicTraitWeight #9bfbff {
  +mechanicId: int
  +userTrait: UserTrait
  +weight: float  ' (0.0 â€“ 1.0) '
}

MotivationalMechanic --> "1..*" MechanicTraitWeight : "has"
  
  class LeaderBoardMechanic extends MotivationalMechanic{

  }
  object ProgramAdherenceLeaderboard
  ProgramAdherenceLeaderboard : LeaderBoardMechanic
  ProgramAdherenceLeaderboard : weights = [ExperienceAndLevelSystemToPersonal_MasteryMapping]
  ProgramAdherenceLeaderboard --> LeaderBoardMechanic : "instance of"

  object PerformanceLeaderboard
  PerformanceLeaderboard : LeaderBoardMechanic
  PerformanceLeaderboard : weights = [ExperienceAndLevelSystemToPersonal_MasteryMapping]
  PerformanceLeaderboard --> LeaderBoardMechanic : "instance of"

  class Mapping {
    Trait : UserTrait
    Mechanic: MotivationalMechanic
    weight: float
  }
  Mapping --> UserTrait : "has"
  Mapping --> MotivationalMechanic : "references"

  MotivationalMechanic --> Mapping: "selected based on"

  object ExperienceAndLevelSystemToPersonal_MasteryMapping {
    Trait = Personal_Mastery
    Mechanic = ExperienceAndLevelSystem
    weight = 0.3
  }
  ExperienceAndLevelSystemToPersonal_MasteryMapping : Mapping

  

}

@enduml7
